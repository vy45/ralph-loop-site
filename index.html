<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ralph Loop — Practical Systems Thinking for AI Work</title>
    <meta
      name="description"
      content="A modern, practical guide to the Ralph Loop: what it is, core philosophy, workflow, examples, and implementation guidance for real projects."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="bg-orb orb-1" aria-hidden="true"></div>
    <div class="bg-orb orb-2" aria-hidden="true"></div>

    <header class="hero" id="top">
      <div class="container hero-wrap">
        <div class="hero-copy">
          <p class="eyebrow">AI Engineering Pattern</p>
          <h1>Understanding the Ralph Loop</h1>
          <p class="lead">
            The Ralph Loop is an iterative workflow for AI agents: run a focused task,
            verify results, save state outside the model, then restart with fresh context.
            The power comes from repetition + feedback, not one giant prompt.
          </p>

          <div class="hero-chips">
            <span>Fast iterations</span>
            <span>External memory</span>
            <span>Test-gated output</span>
          </div>

          <nav class="quick-nav" aria-label="Section navigation">
            <a href="#what-is">What is Ralph Loop</a>
            <a href="#philosophy">Core Philosophy</a>
            <a href="#how-it-works">How it works</a>
            <a href="#examples">Practical examples</a>
            <a href="#meta-comment">Meta Comment</a>
            <a href="#my-thoughts">My Thoughts & implementation guidance</a>
          </nav>
        </div>

        <aside class="hero-panel" aria-label="Ralph Loop at a glance">
          <h2>Loop Pattern</h2>
          <ol>
            <li>Pick one task</li>
            <li>Run the agent</li>
            <li>Execute checks</li>
            <li>Persist outcomes</li>
            <li>Restart clean</li>
          </ol>
          <p>
            A stable structure with adaptable outcomes — designed to turn model variability into
            reliable engineering progress.
          </p>
        </aside>
      </div>
    </header>

    <main class="container main-grid">
      <section id="what-is" class="panel reveal">
        <h2>What is Ralph Loop</h2>
        <p>
          Ralph Loop is a lightweight orchestration pattern (often a shell loop) used to run
          an AI coding agent repeatedly against a clear task list. Instead of keeping one
          very long conversation, each iteration starts fresh and reads project state from
          files, tests, and version control.
        </p>
        <p>
          In simple terms:
          <strong>attempt → check → record → restart</strong>. This keeps delivery grounded in
          verifiable artifacts instead of fragile conversation memory.
        </p>
      </section>

      <section id="philosophy" class="panel reveal">
        <h2>Core Philosophy</h2>
        <div class="cards-2">
          <article class="mini-card">
            <h3>Fresh context beats bloated context</h3>
            <p>New runs avoid conversation fatigue and context rot.</p>
          </article>
          <article class="mini-card">
            <h3>External memory wins</h3>
            <p>Reliable state lives in files, tests, and git—not transient chat memory.</p>
          </article>
          <article class="mini-card">
            <h3>Small tasks compound</h3>
            <p>One clear task per loop creates momentum and easier quality control.</p>
          </article>
          <article class="mini-card">
            <h3>Feedback is non-negotiable</h3>
            <p>Checks are the steering wheel that keeps loops productive.</p>
          </article>
        </div>
      </section>

      <section id="how-it-works" class="panel reveal">
        <h2>How it works</h2>
        <div class="timeline">
          <article>
            <span>01</span>
            <div>
              <h3>Pick one unfinished task</h3>
              <p>Define the scope and done criteria before execution.</p>
            </div>
          </article>
          <article>
            <span>02</span>
            <div>
              <h3>Run the agent on only that task</h3>
              <p>Single-focus loops reduce cross-task confusion and drift.</p>
            </div>
          </article>
          <article>
            <span>03</span>
            <div>
              <h3>Execute checks</h3>
              <p>Run tests, lint, type-check, and any manual validation required.</p>
            </div>
          </article>
          <article>
            <span>04</span>
            <div>
              <h3>Persist outcomes</h3>
              <p>Commit code, update docs/task board, and capture lessons.</p>
            </div>
          </article>
          <article>
            <span>05</span>
            <div>
              <h3>Restart with fresh context</h3>
              <p>The next pass inherits artifacts, not a bloated chat transcript.</p>
            </div>
          </article>
        </div>

        <div class="callout">
          <p>
            Key idea: the loop is deterministic in structure, but adaptable in outcomes. It harnesses
            non-deterministic model behavior through repeated, test-gated attempts.
          </p>
        </div>
      </section>

      <section id="examples" class="panel reveal">
        <h2>Practical examples</h2>
        <div class="cards-3">
          <article class="example-card">
            <h3>Feature delivery</h3>
            <p>
              Split “build user dashboard” into micro-tasks: API integration, cards,
              loading/error states, accessibility, tests. Close each slice only after checks pass.
            </p>
          </article>
          <article class="example-card">
            <h3>Bug fixing</h3>
            <p>
              Reproduce bug → write failing test → implement fix → run regression suite.
              Failed checks become the next loop input.
            </p>
          </article>
          <article class="example-card">
            <h3>Refactoring with guardrails</h3>
            <p>
              Improve modules incrementally while preserving behavior via tests and snapshots.
              Lower risk, higher consistency.
            </p>
          </article>
        </div>
      </section>

      <section id="meta-comment" class="panel panel-meta reveal">
        <h2>Meta Comment</h2>
        <p>
          Explaining Ralph Loop is slightly ironic: the concept argues for short, focused cycles,
          while explanations can become broad and abstract. To stay faithful to the philosophy,
          this page keeps the narrative practical and modular.
        </p>
        <p>
          Even this explanation is loop-shaped: define the model, test with examples,
          then refine toward implementation.
        </p>
      </section>

      <section id="my-thoughts" class="panel reveal">
        <h2>My Thoughts & implementation guidance</h2>
        <p>
          Ralph Loop is most useful when treated as engineering discipline, not a magic button.
          It shines when quality gates are explicit and tasks are deliberately scoped.
        </p>
        <div class="implementation-grid">
          <article>
            <h3>1) Define a task ledger</h3>
            <p>Keep one-line acceptance criteria for every task.</p>
          </article>
          <article>
            <h3>2) Create quality gates</h3>
            <p>Set mandatory tests/lint/type-check/build before closure.</p>
          </article>
          <article>
            <h3>3) Standardize project memory</h3>
            <p>Maintain AGENTS.md-style conventions and recurring learnings.</p>
          </article>
          <article>
            <h3>4) Keep loops short</h3>
            <p>Ten small loops beat one giant loop for debugging and review.</p>
          </article>
          <article>
            <h3>5) Add human review checkpoints</h3>
            <p>Reconfirm architecture and product direction at key milestones.</p>
          </article>
          <article>
            <h3>6) Measure outcomes</h3>
            <p>Track cycle time, pass rate, rework, and escaped defects.</p>
          </article>
        </div>
      </section>
    </main>

    <footer class="container footer">
      <p>Built as a fast, GitHub Pages-ready static site.</p>
      <a href="#top" aria-label="Back to top">Back to top ↑</a>
    </footer>

    <script>
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) entry.target.classList.add('in-view');
          });
        },
        { threshold: 0.12 }
      );
      document.querySelectorAll('.reveal').forEach((el) => observer.observe(el));
    </script>
  </body>
</html>
